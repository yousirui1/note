/**************************************
*FileName: LoadingLabel.cs
*User: ysr 
*Data: 2018/1/24
*Describe: 动态载入效果
**************************************/

i/o文件操作

using (StringReader sr = new StringReader(txtFile.text))
{
	string line;		
	while(null != (linue = sr.ReadLine()))
	{
		//去掉字符串左侧和右侧的空格
		line = line.Trim();
		if(line.Length <= 0 || line.StartsWith("#")
		{
			continue;
		}	

		//查找字符串 失败返回-1
		int idx = line.IndexOf("=");
	
		if(-1 !- idx)
		{
			//按照长度查找 (beginIndex, endIndex)	
			string key = line.Substring(0, idx);
			string value = line.Substring(idx + 1);

			switch(key)
			{
				case "verName"
				{
	
				}
				break;
			}
		}
	}
}
int idx = s_externalPath.LastIndexOf("game_Data");  //最后一个开始索引
(bool)s_externalPath.StartsWith("/");
(bool)s_externalPath.EndsWith("/");   //判断最后一位是否为'/'



本地持久数据

string ret = PlayerPrefs.GetString(PREF_NAME + KEY_LAST_MODIFIED, "");
PlayerPrefs.SetString(PREF_NAME + KEY_LAST_MODIFIED, ifModifiedSince);


全局Scance的GameObject
public static Audio2D create(MainLooper looper, AudioCache audioCache)
{
	GameObject go = new GameObject("audio");
	MonoBehaviour.DontDestroyOnLoad(go);		//场景跳转时，保留游戏对象
	Audio2D a2d = go.AddComponent<Audio2D>();
	a2d.setup(looper, audioCache);

	return a2d;
}


手机端文件路径
Android 获取文件夹读写权限时 可以对根目录进行读写
s_externalPath= "/sdcard/fsdzz/";
没有读写权限的话
//ios 和Android 都可以使用 沙盒内存，不可见
s_externalPath = Application.persistentDataPath;  
//win 和编辑器中
s_externalPath = Application.dataPath;


HashSet:
	HashSet实现了Set接口，不允许集合中出现重复元素 仅储存对象
HashMap:
	HashMap实现了Map接口，Map接口对键值对进行映射, Map中不允许出现重复的键(Key)

HashSet就是限制了功能的HashMap 	


加载资源
Resouces.Load();
Resouces.UnloadUnusedAssets();
Resouces.LoadAsync();   //异步加载   type 可以装载任意类型
Resouces.LoadAll();		//加载Resouces文件夹中的path文件夹或者文件夹中的所有资源 type 类型过滤

System.GC.Collect();  //强制对所有迭代垃圾进行回收



































\\rtx\soft\游戏部\开发组\_apk\法师大作战

bugly接入参数备注，需要的自取：产品名称： 法师大作战--iOSApp ID  ： af1f421579
App Key： 9fba4a90-e943-48f5-a1bb-56a63824470a

产品名称： 法师大作战--安卓
App ID  ： 96544d730c
App Key： 7324b538-aab7-4b61-a823-8e1e695a8738

using LitJson;
using System.Runtime.Serialization;

OnDestroy

RespThirdLoad mapVal = JsonMapper.ToObject<RespThirdLoad> (js_map);

  catch (SerializationException ex) 
            {   
                //直接显示: 游戏数据损坏, 请重新启动游戏;
                Log.w<ValUtils>(ex.Message);
                Debug.Log("SerializationException ysr"+ex.Message);
                tellOnTableLoadErr();
            }   
            catch (Exception ex) 
            {   
                Debug.Log("Exception ysr"+ ex.Message + ", " + ex.GetType().FullName);
                Log.w<ValUtils>(ex.Messasoge + ", " + ex.GetType().FullName);
                tellOnTableLoadErr();
            }   



//2向量的夹角   不能默认为0，0，0 为原点  计算所以值都为0
Vector3.Angle(new Vector3(1,0,0),dVec);


https://sirui.you:

Debug.Log (TAG +":" +"onHttpErr");

svn://121.40.149.87/magician_resource 

字符串转数字
Convert.ToInt32(code)
分隔符
string[] sArray=val.add.Split(new char[2]{'j','s'});
string[] sArray=val.add.Split(',');

/ 数值表json地址
http://svn.tpadsz.cn/repo/images_tp/magician.io 


用户名：gjw 
密码：gjw123json的账号密码

//箭头
http://blog.csdn.net/ybhjx/article/details/58611010


对齐设置
Snap settings


假设你已经有了一套名为id_rsa的公秘钥，将要生成的公秘钥名称为gitlab，你也可以使用任何你喜欢的名字。记得把以下命令中的YOUR_EMAIL@YOUREMAIL.COM改为你的Email地址

ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/gitlab

说明：

（1）-f后面的参数是自定义的SSH Key的存放路径，将来生成的公秘钥的名字分别是gitlab.pub和gitlab

（2）其他的和上面生成密钥的步骤相同，只是多了下面的配置的步骤

2.配置自定义的公秘钥名称

在SSH用户配置文件~/.ssh/config中指定对应服务所使用的公秘钥名称，
如果没有config文件的话就新建一个(vim ~/.ssh/config)，并输入以下内容(可以添加多个)：

Host gitlab.com www.gitlab.com

IdentityFile ~/.ssh/gitlab




gate.gateHandler.queryEntry connector.entryHandler.entry 
2）将隐藏的文件显示出来在终端输入，chflags nohidden /Users/yourname/Library  
3）讲显示的文件隐藏在终端输入，chflags hidden /Users/yourname/Library  

比较	（大写）String.Compare(str1, str2)
查找	strXX.IndexOf(‘查找的内容’, 0)
删除	strXX.Remove(n)
替换	strXX.Replace(‘查找的内容’, ‘替换的内容’)
插入	strXX.Insert(n, “插入的内容”)
取字符段	strXX.Substring(n, 10)
分割	strXX.Split(‘,’)


fetch与pull的区别：如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 
git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 并不会自动合并或修改你当前的工作,必须要手动进行合并。 

git fetch --all
git reset --hard origin/master

Host gitlab.tpadsz.cnIdentityFile ~/.ssh/gitlab
Host github.com
IdentityFile ~/.ssh/github

git Unity 忽略文件
vi .gitignore

/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/Assets/AssetStoreTools*

# Autogenerated VS/MD/Consulo solution and project files
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd

# Unity3D generated meta files
*.pidb.meta

# Unity3D Generated File On Crash Reports
sysinfo.txt

# Builds
*.apk
*.unitypackage


 culling Mask本质为一个Int类型的值，32位，每一位代表一层，比如开启第一层，cullingMask = 1<<2。1<<index，1的二进制是00000000 00000001，1<<index就是左移index位，如1<<2,就是00000000 00000100。当相机什么都不渲染，即cullingMask为Nothing时，cullingMask等于0，即32个0，当相机渲染everything时，cullingMask为-1，即32个1（补码）


//localposition 父物体为坐标轴
position 世界坐标为坐标系


List 排序

public class Player
{
    public string Name { get; set; }
    public int Total { get; set; }

    public Player(string name, int total)
    {
        Name = name;
        Total = total;
    }
}

lst.Sort(delegate(Player x, Player y)
{
    return y.Total.CompareTo(x.Total);
});

Player  = list_user.Find ((Player player) => player.m_uid == data.nickname) as Player;



 public static void Main()
         {
               //一、创建泛型哈希表，然后加入元素
               Dictionary<string, string> oscar = new Dictionary<string, string>();
               oscar.Add("哈莉?贝瑞", "《死囚之舞》");
               oscar.Add("朱迪?丹奇", "《携手人生》");
               oscar.Add("尼科尔?基德曼", "《红磨坊》");
               oscar.Add("詹妮弗?康纳利", "《美丽心灵》");
               oscar.Add("蕾妮?齐维格", "《BJ单身日记》");

               //二、删除元素
               oscar.Remove("詹妮弗?康纳利");

               //三、假如不存在元素则加入元素
               if (!oscar.ContainsKey("茜茜?斯派克")) oscar.Add("茜茜?斯派克", "《不伦之恋》");
               

               //四、显然容量和元素个数
               Console.WriteLine("元素个数: {0}", oscar.Count);

               //五、遍历集合
               Console.WriteLine("74届奥斯卡最佳女主角及其电影：");
               foreach (KeyValuePair<string, string> kvp in oscar)
               {
                      Console.WriteLine("姓名：{0},电影：{1}", kvp.Key, kvp.Value);
               }

              //六、得到哈希表中键的集合
              Dictionary<int, List<object>>.KeyCollection keyColl = oscar.Keys;

class object
{
	int id;

	list[0].

}
              //遍历键的集合
              Console.WriteLine("最佳女主角：");
              foreach (string s in oscar.Keys)
              {
                   Console.WriteLine(s);
              }

              //七、得到哈希表值的集合
              Dictionary<string, string>.ValueCollection valueColl = oscar.Values;
              //遍历值的集合
              Console.WriteLine("最佳女主角电影：");
              foreach (string s in oscar.Values)
              {
                   Console.WriteLine(s);
              }

              //八、使用TryGetValue方法获取指定键对应的值
              string slove = string.Empty;
              if (oscar.TryGetValue("朱迪?丹奇", out slove))
                     Console.WriteLine("我最喜欢朱迪?丹奇的电影{0}", slove);
              else
                     Console.WriteLine("没找到朱迪?丹奇的电影");

              //九、清空哈希表
              oscar.Clear();
              Console.ReadLine();
       }



JsonObject jsMsg = (JsonObject)SimpleJson.SimpleJson.DeserializeObject (stObj);

string st = SimpleJson.SimpleJson.SerializeObject (buf);
apVal mapVal = SimpleJson.SimpleJson.DeserializeObject<MapVal> (message);

IOS:
Application.dataPath :                      Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data
Application.streamingAssetsPath :   Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw
Application.persistentDataPath :      Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents
Application.temporaryCachePath :   Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches

Android:
Application.dataPath :                         /data/app/xxx.xxx.xxx.apk
Application.streamingAssetsPath :      jar:file:///data/app/xxx.xxx.xxx.apk/!/assets
Application.persistentDataPath :         /data/data/xxx.xxx.xxx/files
Application.temporaryCachePath :      /data/data/xxx.xxx.xxx/cache

Windows:
Application.dataPath :                         /Assets
Application.streamingAssetsPath :      /Assets/StreamingAssets
Application.persistentDataPath :         C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductName
Application.temporaryCachePath :      C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName

ac:
Application.dataPath :                         /Assets
Application.streamingAssetsPath :      /Assets/StreamingAssets
Application.persistentDataPath :         /Users/xxxx/Library/Caches/CompanyName/Product Name
Application.temporaryCachePath :     /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product Name


Windows Web Player:
Application.dataPath :             file:///D:/MyGame/WebPlayer (即导包后保存的文件夹，html文件所在文件夹)
Application.streamingAssetsPath :
Application.persistentDataPath :
Application.temporaryCachePath :



//刚体速度设置
rigidbody .velocity

//渲染器.材质.颜色
oldcolor=renderer.material.color;

//旋转
transform.Rotate(0,180*Time.deltaTime,0);

//周围旋转
transform.RotateAround(cy.position,Vector3.up,100*Time.deltaTime);

//上下移动
transform.Translate(0, -speed*Time.deltaTime, 0); 



//GUI菜单
function mydowin1(){
        //GUI布局.标签
		GUILayout.Label ("","mylabel2");
		//开始水平组
        GUILayout.BeginHorizontal();
        //工具栏
		n1=GUILayout.Toolbar(n1,answer);
        //结束水平组
		GUILayout.EndHorizontal();
		//窗口坐标
	    GUI.DragWindow( Rect(0,0,1000,1000));	
}

//忽略碰撞
Physics.IgnoreCollision( transform.root.collider,newcoconut.collider,true);	



//Updat是在每次渲染新的一帧的时候才会调用
FixedUpdate，是在固定的时间间隔执行，不受游戏帧率（fps）的影响
FixedUpdate的时间间隔可以在项目设置中更改，Edit->Project Setting->time 找到Fixed timestep。就可以修改了


//调用其他物体上的脚本函数
gameObject.Find("wenzi").GetComponent(GUIText).text="累加结果是："+m;、

//鼠标进入
function OnMouseOver(){
}
function OnMouseExit(){
}
function OnMouseDown(){
    audio.Pause();  //音乐暂停
}

//亮度调节
function Start () {
		thelight=GameObject.Find("Spotlight1");
		thetxt=GameObject.FindWithTag("txt");
		theCube1=GameObject.Find("Cube1");
}
function Update () {
		if(Input.GetKey(KeyCode.L)){thelight.light.intensity+=0.01;
			thetxt.guiText.text="当前亮度："+thelight.light.intensity;
		}
		if(Input.GetKey(KeyCode.K)){thelight.light.intensity-=0.01;
			thetxt.GetComponent(GUIText).text="当前亮度："+thelight.light.intensity;
		}
		
		if(Input.GetKey(KeyCode.S)){theCube1.SendMessage("Start");
			
		}
}


//固定时间刷新不受fps的影响
function FixedUpdate(){
		if (grounded){
			movedirection=Vector3(Input.GetAxis("Horizontal"),0,Input.GetAxis("Vertical"));
			movedirection=transform.TransformDirection(movedirection);
			movedirection*=speed ;
			if(Input.GetButton("Jump")){
				movedirection.y=jumpspeed;			
			}	
		}
		movedirection.y -= gravity*Time.deltaTime;	
		var controller:CharacterController=GetComponent(CharacterController);
		//移动命令
		
		var flags=controller.Move(movedirection*Time.deltaTime);
		//CollisionFlags.CollidedBelow    底部发生了碰撞“flags & CollisionFlags.CollidedBelow”返回1
		//CollisionFlags.CollidedNone   没发生碰撞“flags & CollisionFlags.CollidedNone”返回1
		//CollisionFlags.CollidedSides    四周发生了碰撞“flags & CollisionFlags.CollidedSides”返回1
		//CollisionFlags.CollidedAbove   顶端发生了碰撞“flags & CollisionFlags.CollidedAbove”返回1
		// 单个& 表示比较两个二进制数值
		//位掩码技术
		grounded=(flags & CollisionFlags.CollidedBelow)!=0;  
				
}

@script RequireComponent(CharacterController)

//碰撞检测函数
 function OnControllerColliderHit(hit:ControllerColliderHit){
 	 if(hit.gameObject.name!="Plane")
  }
function OnTriggerEnter(col:Collider){}

//光线投射
Physics.Raycast(transform.position,transform.forward,hit,10)

function OnTriggerEnter(col:Collider){
function OnTriggerEnter(col:Collider){
		if(col.gameObject.tag=="Player"){
				transform.FindChild("door").SendMessage("doorcheck");

//检测角色控制器与其他碰撞器碰撞的专用函数	
function  OnControllerColliderHit(hit:ControllerColliderHit){
//判断与角色控制器碰撞的物体的标签名
	if(hit.gameObject.tag=="playerDoor" && doorisopen==false){
		currentdoor=hit.gameObject;
		door(true,door_open_sound,"dooropen",currentdoor);
	}
		
//运行一次动画	Thisdoor.audio.PlayOneShot(a_clip);

//运行父物体上的动画
thisdoor.transform.parent.animation.Play(anim_name);

		
var controller:CharacterController=GetComponent(CharacterController);
		//移动命令
		
		var flags=controller.Move(movedirection*Time.deltaTime);
		//CollisionFlags.CollidedBelow    底部发生了碰撞“flags & CollisionFlags.CollidedBelow”返回1
		//CollisionFlags.CollidedNone   没发生碰撞“flags & CollisionFlags.CollidedNone”返回1
		//CollisionFlags.CollidedSides    四周发生了碰撞“flags & CollisionFlags.CollidedSides”返回1
		//CollisionFlags.CollidedAbove   顶端发生了碰撞“flags & CollisionFlags.CollidedAbove”返回1
		// 单个& 表示比较两个二进制数值
		//位掩码技术
		grounded=(flags & CollisionFlags.CollidedBelow)!=0;  
				
}
@script RequireComponent(CharacterController)







var collectSound:AudioClip;
//电池图片数组与引用变量
var textures:Texture2D[];
var powergui_bl:GUITexture;
//仪表盘主材质纹理数组与引用变量
var main_texture:Texture2D[];
var chargemeter_bl:Renderer;

	 

    
	 	 	 
function Start () {
	charge=0;
}
//收集能量源函数
function cellpickup(){
	//播放“收集音频”
	AudioSource.PlayClipAtPoint(collectSound,transform.position);
	//收集计数
	charge++;
	//替换GUITexture的texture
	powergui_bl.texture=textures[charge];
	//替换Renderer下的material.mainTexture
	chargemeter_bl.material.mainTexture=main_texture[charge];
	
}

















private var doorisopen:boolean=false;
private var doortimer:float=0.0;

var door_open_time:float=3.0;
var door_open_sound:AudioClip;
var door_shut_sound:AudioClip;
var wenzi_bl:GUIText;
var wenzi_timer:float=0.0;
var win:boolean=false;
var rect:Rect;
var rect1:Rect;
var myguiskin:GUISkin;
var mywinskin:GUISkin;
var ture:Texture2D;
var tog:boolean;
var text:String="Hello World!";
var n:int;
var n1:int;
var answer:String[]=["答案1","答案2","答案3"];
var hs:float;

function Start () {
		rect=Rect(100,50,800,500);
		rect1=Rect(200,300,600,100);

}

function OnGUI(){
		GUI.skin=myguiskin;
		rect=GUI.Window(0,rect,mydowin,"菜单窗口");
		if(tog){rect1=GUI.Window(1,rect1,mydowin1,"菜单窗口1","mywinskin");}
		
		
}

function mydowin(){
		GUILayout.BeginHorizontal();
		if(GUILayout.Button("button")){
				print("button_ok");
		
		}

		GUILayout.Label (ture);
		tog=GUILayout.Toggle(tog,"toggle");
		
		
		text=GUILayout.TextField(text,50);
		GUILayout.EndHorizontal();
		GUILayout.Label (hs.ToString(),"mylabel");
		hs=GUILayout.HorizontalSlider(hs,0.0,100.0);
		
		GUILayout.BeginHorizontal();
		n=GUILayout.Toolbar(n,answer);
		GUILayout.Label ("你选择的是：答案"+n,"mylabel");
		GUILayout.EndHorizontal();
	GUI.DragWindow( Rect(0,0,1000,1000));	
}


/*物体上下移动
 * 和选择
 */

private var isDown :boolean = true;
private var startPosition : float ;

function Start() {
    startPosition = transform.position.y;
}

function Update(){
    if(isDown){
        transform.Translate(0, -speed*Time.deltaTime, 0); //上下移动
        transform.Rotate(0, -speed*Time.deltaTime, 0); //旋转
    }else{
        transform.Translate(0, speed*Time.deltaTiem, 0);
        transform.Rotate(0, speed*Time.deltaTime, 0);
    }
    if(transform.position.y - startPosition >0){isDown = true};
    if(transform.position.y - startPosition < -0.4){isDown = false};
}




/*
 *  网络编程服务器，实现了简单的连接功能指定port 和ip
 */
using UnityEngine;
using System.Collections;

public class network : MonoBehaviour {
	private string roip="127.0.0.1";
	private int rport = 10000;
	private int concount = 15;
	private bool usenat = false;

	void OnGUI()
	{
		switch(Network.peerType)
		{
		case NetworkPeerType.Disconnected:
			StartServer();
			break;
		case NetworkPeerType.Server:
			Onserver();
			break;
		case NetworkPeerType.Connecting:
			break;
		}
	}
	void StartServer(){
		roip = GUI.TextField (new Rect (10, 30, 100, 20), roip);
		if (GUI.Button (new Rect (10, 50, 100, 30), "创建服务器")) {
			Network.incomingPassword="unitynetwork";
			NetworkConnectionError erro =Network.InitializeServer(concount,rport,usenat);
			Debug.Log(erro);
		}
	}

	void Onserver(){
		GUILayout.Label ("创建服务器成功！等待连接。。。");
		string ip = Network.player.ipAddress;
		int port = Network.player.port;
		GUILayout.Label ("IP地址" + ip + "\n端口号" + port);
		int connectlength = Network.connections.Length;
		for(int i = 0;i<connectlength;i++){
			GUILayout.Label("连接的IP"+Network.connections[i].ipAddress);
			GUILayout.Label("连接的端口"+Network.connections[i].port);
		}
		if(GUI.Button(new Rect(10,340,100,30),"断开连接")){
			Network.Disconnect(200);
		}
	}
}


/*
 *客户端程序
 */
using UnityEngine;
using System.Collections;

public class networkclient : MonoBehaviour {
	private string roip="请输入要连接的IP";
	private int iport=10000;
	private bool usenat=false;
	void OnGUI()
	{
		switch(Network.peerType)
		{
		case NetworkPeerType.Disconnected:
			Startconnect();
			  break;
		case NetworkPeerType.Client:
			Clientto();
			break;
		case NetworkPeerType.Connecting:
			Debug.Log("连接中");
			break;
		}
    }

	void Startconnect()
	{
		roip = GUILayout.TextField (roip);
		if (GUILayout.Button ("连接服务器")) {
			NetworkConnectionError erro=Network.Connect(roip,iport,"unitynetwork");
			Debug.Log(erro);
		}
	}

	void Clientto(){
		GUILayout.Label ("成功连接到服务器！");
	}

	void OnConnectedToServer(){
	foreach(GameObject go in FindObjectsOfType(typeof(GameObject))){
			go.SendMessage("OnNetworkLoaded",SendMessageOptions.DontRequireReceiver);
		}
	}
}


